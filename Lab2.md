## 实验2 语义分析

### 实验内容
1. 必做内容

2. 选做内容: 选做2.1, 2.2, 2.3, 3选1, 每组只需完成一个选做要求, 多做不额外给分
    - 选做2.1: 组号1-8 (e.g. 组号为1,2,...,8选做2.1)
    - 选做2.2: 组号9-16 (e.g. 组号为9,10,...,16选做2.2)
    - 选做2.3: 组号17-25 (e.g. 组号为17,18...,25选做2.3)

### 评分标准：

1. 基本: 按照提交要求提交指定内容(源程序,可执行文件,实验报告), 程序可以通过 Makefile 编译和运行;

2. 必做内容: 对所有的组, 测试用例相同, 输出要求相同;

3. 选做内容: 对不同的组, 测试用例相同, 输出要求不同;

4. 额外加分: 对于必做要求和选做要求均会设置难度较大的测试用例用于加分


### 实验注意事项

1. 与实验一不同的是，实验二不再借助已有的工具，所有的任务都必须手写代码来完成, 新增代码量大约在 600-800 行左右.
    - 实验二任务较为细致、琐碎, 尽可能对每个产生式设置一个处理函数.
    - 实验二在实验一的基础上完成，不需要对原有的程序进行大量修改，进行适当扩展就可；
    - 后续的实验三中还会用到本次实验已经写好的代码, 并会对本次实验中的每个函数进行大量修改和扩充，请系统地设计代码结构和各模块之间的接口；

2. 代码部分文件结构，仅供参考
```
./Code
├── lexical.l   # Lab1 词法正则
├── syntax.y    # Lab1 文法
├── main.c      # 入口函数
├── Makefile    # 原始Makefile
├── node.c      # Lab1 语法分析: 语法树建立和打印输出
├── node.h
├── semantic.c  # Lab2 语义分析: 在语法树的基础上进行符号表操作和语义分析
├── semantic.h
└──
```

3. `main.c` 部分代码, 仅供参考
```c
int main(int argc, char** argv){
    if (argc <= 1){
        return 1;
    }
    FILE* fp = fopen(argv[1],"r");
    if (!fp){
        perror(argv[1]);
        return 1;
    }
    yylineno=1;
    yyrestart(fp);
    yyparse();
    if(errorNum == 0){
        initHashtable();
        traverseTree(Root);
    }
    return 0;
}
```

4. Makefile文件在编写和测试代码中可自行测试修改, 但最终提交时请务必通过原始Makefile的编译, 对提交的代码文件最终会用原始Makefile进行测试

### 截止日期
- 2020年11月13日 23:59:59(周五晚)之前提交到助教邮箱


